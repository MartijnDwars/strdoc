
<module>
  <name>collection/list/common</name>
  <description><![CDATA[
                        This module contains basic functionality for manipulating lists.
                        
                        
                        ]]></description>
  
  
  
  <strategy>
    <name>list-loop</name>
    <description><![CDATA[
                          Iterative loop over a list applying s to each element.
                          
                          
                          ]]></description>
    <start>18</start>
    <end>19</end>
    <type><![CDATA[List(a) -> List(a)]]></type>
    <param><![CDATA[Strategy to apply to every element (a -> _)]]></param>
  </strategy>
  
  
  <strategy>
    <name>list-fold</name>
    <description><![CDATA[
                          Iterative fold over a list applying s to each element and
                          accumulator acc from left to right.
                          
                          intermediate result is a term argument. The next element
                          of the list is the current term.
                          
                          ]]></description>
    <start>31</start>
    <end>32</end>
    <type><![CDATA[List(a) -> c]]></type>
    <param><![CDATA[Strategy applied for folding. The current]]></param>
    <param><![CDATA[Initial value for folding (type: c)]]></param>
  </strategy>
  
  
  <strategy>
    <name>Hd</name>
    <description><![CDATA[
                          ]]></description>
    <start>37</start>
    <end>37</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>Tl</name>
    <description><![CDATA[
                          ]]></description>
    <start>40</start>
    <end>40</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>Last</name>
    <description><![CDATA[
                          ]]></description>
    <start>43</start>
    <end>43</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>MkSingleton</name>
    <description><![CDATA[
                          
                          ]]></description>
    <start>49</start>
    <end>50</end>
    <type><![CDATA[a -> List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>split-Cons</name>
    <description><![CDATA[
                          Splits a Cons into a tuple with head and tail.
                          
                          
                          ]]></description>
    <start>57</start>
    <end>58</end>
    <type><![CDATA[List(a) -> (a, List(a))]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>MkCons</name>
    <description><![CDATA[
                          Makes a Cons out of a tuple with head and tail. The
                          tail must be a list, but may be the empty list.
                          
                          
                          ]]></description>
    <start>66</start>
    <end>67</end>
    <type><![CDATA[(a, List(a)) -> List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>is-list</name>
    <description><![CDATA[
                          Succeeds if the input term is a list.
                          
                          
                          ]]></description>
    <start>76</start>
    <end>76</end>
    <type><![CDATA[List(a) -> _]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>map</name>
    <description><![CDATA[
                          Apply a strategy to each element of a list.
                          
                          
                          ]]></description>
    <start>85</start>
    <end>86</end>
    <type><![CDATA[ List(a) -> List(b)]]></type>
    <param><![CDATA[s is applied to all elements: a -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>map1</name>
    <description><![CDATA[
                          ]]></description>
    <start>89</start>
    <end>90</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>reverse-map</name>
    <description><![CDATA[
                          In reverse order, apply a strategy to each element of a list.
                          
                          
                          ]]></description>
    <start>98</start>
    <end>99</end>
    <type><![CDATA[ List(a) -> List(b)]]></type>
    <param><![CDATA[s is applied to all elements: a -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>list</name>
    <description><![CDATA[
                          
                          
                          ]]></description>
    <start>106</start>
    <end>107</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>list-some</name>
    <description><![CDATA[
                          Apply a strategy to some elements in a list. The elements
                          of the original list will be kept unchanged when the
                          strategy s fails.
                          
                          
                          ]]></description>
    <start>117</start>
    <end>118</end>
    <type><![CDATA[   List(a) -> List(b)]]></type>
    <param><![CDATA[s       a -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>length</name>
    <description><![CDATA[
                          Returns the length of a list.
                          
                          
                          ]]></description>
    <start>126</start>
    <end>127</end>
    <type><![CDATA[List(a) -> Int]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>elem</name>
    <description><![CDATA[
                          Succeeds if the term is in the list.
                          
                          
                          ]]></description>
    <start>134</start>
    <end>135</end>
    <type><![CDATA[ (a, List(a)) ->? List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>elem</name>
    <description><![CDATA[
                          Succeeds if the term is in the list, using the given
                          strategy for determining equality.
                          
                          
                          ]]></description>
    <start>144</start>
    <end>145</end>
    <type><![CDATA[ (a, List(a)) ->? List(a or b)]]></type>
    <param><![CDATA[(a, a) ->? b]]></param>
  </strategy>
  
  
  <strategy>
    <name>fetch</name>
    <description><![CDATA[
                          Find first list element for which s succeeds.
                          
                          
                          ]]></description>
    <start>154</start>
    <end>155</end>
    <type><![CDATA[ List(a) -> List(a or b)]]></type>
    <param><![CDATA[a -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>fetch-elem</name>
    <description><![CDATA[
                          Return first list element for which s succeeds.
                          
                          
                          ]]></description>
    <start>163</start>
    <end>164</end>
    <type><![CDATA[ List(a) -> a]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>split-fetch</name>
    <description><![CDATA[
                          Splits a list in two parts at the first point where s succeeds.
                          
                          The element to which s was applied is not part of the result. split-fetch
                          fails if s cannot be applied to any of the elements.
                          
                          Examples:
                          <split-fetch(\ 3 -> 6 \)> [1, 2, 3] => ([1,2], [])
                          <split-fetch(\ 3 -> 6 \)> [2, 3, 4] => ([2], [4])
                          <split-fetch(\ 3 -> 6 \)> [3, 4, 5] => ([], [4,5])
                          not(<split-fetch(\ 3 -> 6 \)> [8, 7, 6])
                          
                          
                          ]]></description>
    <start>182</start>
    <end>183</end>
    <type><![CDATA[ List(a) -> (List(a), List(a))]]></type>
    <param><![CDATA[a ->? _]]></param>
  </strategy>
  
  
  <strategy>
    <name>split-fetch-keep</name>
    <description><![CDATA[
                          Splits a list in two parts at the point where s succeeds, keeping the
                          element at which s succeeded.
                          
                          Unlike split-fetch, this strategy keeps the dividing element as part of
                          the result as the second element in the triple: (before, split, after)
                          
                          split-fetch-keep fails if s cannot be applied to any of the elements.
                          
                          
                          ]]></description>
    <start>197</start>
    <end>198</end>
    <type><![CDATA[ List(a) -> (List(a), b, List(a))]]></type>
    <param><![CDATA[a -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>list-tokenize</name>
    <description><![CDATA[
                          Breaks a list into multiple parts (tokens).
                          
                          The term argument sep is a list of delimiters (elements that separate
                          tokens from one another), which is used to split the list
                          into multiple tokens. The result is a list of lists, i.e. a list
                          of tokens.
                          
                          
                          ]]></description>
    <start>211</start>
    <end>212</end>
    <type><![CDATA[ List(a) -> List(List(a))]]></type>
    <param><![CDATA[List of separator elements.]]></param>
  </strategy>
  
  
  <strategy>
    <name>list-tokenize</name>
    <description><![CDATA[
                          Breaks a list into multiple parts (tokens).
                          
                          The strategy argument sep is used to split the list. Wherever it
                          succeeds, the original list is split, and the parts are returned
                          as a list of lists, i.e. a list of tokens.
                          
                          
                          ]]></description>
    <start>224</start>
    <end>230</end>
    <type><![CDATA[    List(a) -> List(List(a))]]></type>
    <param><![CDATA[s  a -> fail?]]></param>
  </strategy>
  
  
  <strategy>
    <name>at-tail</name>
    <description><![CDATA[
                          Apply a strategy to the tail of a list.
                          
                          
                          ]]></description>
    <start>240</start>
    <end>241</end>
    <type><![CDATA[ List(a) -> List(a or b)]]></type>
    <param><![CDATA[is applied to the tail: List(a) -> List(b)]]></param>
  </strategy>
  
  
  <strategy>
    <name>at-end</name>
    <description><![CDATA[
                          Apply s to the Nil of a list.
                          
                          
                          ]]></description>
    <start>249</start>
    <end>250</end>
    <type><![CDATA[ List(a) -> List(a)]]></type>
    <param><![CDATA[is applied to Nil ([]) and must return a list: List(a) -> List(a)]]></param>
  </strategy>
  
  
  <strategy>
    <name>at-suffix</name>
    <description><![CDATA[
                          Apply a strategy to some suffix of a list.
                          
                          The longest suffix (that is, the first application in a list)
                          is preferred.
                          
                          
                          ]]></description>
    <start>261</start>
    <end>262</end>
    <type><![CDATA[ List(a) -> List(a or b)]]></type>
    <param><![CDATA[is applied to the suffix : List(a) -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>at-suffix-rev</name>
    <description><![CDATA[
                          Apply a strategy to some suffix of a list.
                          
                          The shortest suffix (that is, the last application in a list)
                          is preferred.
                          
                          
                          ]]></description>
    <start>273</start>
    <end>274</end>
    <type><![CDATA[ List(a) -> List(a or b)]]></type>
    <param><![CDATA[is applied to the suffix : List(a) -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>at-last</name>
    <description><![CDATA[
                          Apply s to the last Cons ([_]) of a list.
                          
                          
                          ]]></description>
    <start>282</start>
    <end>283</end>
    <type><![CDATA[ List(a) -> List(a)]]></type>
    <param><![CDATA[Is applied to the [x] and must return a list: List(a) -> List(a)]]></param>
  </strategy>
  
  
  <strategy>
    <name>split-init-last</name>
    <description><![CDATA[
                          Splits a list into a tuple of its init list and last element.
                          
                          Example:
                          <split-init-last> [1, 2, 3, 4] => ([1, 2, 3], 4)
                          <split-init-last> [1]          => ([], 1)
                          
                          
                          ]]></description>
    <start>296</start>
    <end>297</end>
    <type><![CDATA[  List(a) -> (List(a), a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>at-init</name>
    <description><![CDATA[
                          Applies s1 to all elements in a list, except the last, where
                          s2 is applied.
                          
                          
                          ]]></description>
    <start>307</start>
    <end>308</end>
    <type><![CDATA[List(a) -> List(b)]]></type>
    <param><![CDATA[s1 a -> b]]></param>
    <param><![CDATA[s2 a -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>listbu</name>
    <description><![CDATA[
                          Applies a strategy to a list in bottom up order. That is to say,
                          the strategy s will be applied to successively longer excerpts
                          of the list, starting from the end.
                          
                          At the first invocation, s will be applied to the tail of the list,
                          and is expected to return a new list. The last element of the list
                          will then be added in front of this result, and s is applied to
                          this. The recursion continues through all elements from last to
                          first, each time on a longer list, hence "bottom up".
                          
                          Example: <listbu(![9 | <id>])> [1,2,3,4] => [9,1,9,2,9,3,9,4,9]
                          
                          
                          ]]></description>
    <start>326</start>
    <end>327</end>
    <type><![CDATA[    List(a) -> List(b)]]></type>
    <param><![CDATA[s  List(a) -> List(b)]]></param>
  </strategy>
  
  
  <strategy>
    <name>listbu1</name>
    <description><![CDATA[
                          
                          ]]></description>
    <start>332</start>
    <end>333</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>listtd</name>
    <description><![CDATA[
                          Applies a strategy to a list in top down order. That is to say,
                          the strategy s will first be applied to the whole list, then
                          successively shorter excerpts, all the way chopping of elements from
                          the start of the list.
                          
                          At the first invocation, s will be applied to the whole list, and
                          is expected to return a new list. The first element is chopped off
                          this result, and s is applied again, until s has been applied to
                          the empty list. The recursion continues through successively
                          shorter list, hence "top down".
                          
                          it is given, because that will result in non-termination.
                          
                          Example: <listtd(not(?[]) ; ![<sum>] <+ ![])> [1,2,3,4] => [10]
                          
                          
                          ]]></description>
    <start>355</start>
    <end>356</end>
    <type><![CDATA[    List(a) -> List(b)]]></type>
    <param><![CDATA[s  List(a) -> List(b)]]></param>
  </strategy>
  
  
  <strategy>
    <name>listdu</name>
    <description><![CDATA[
                          Applies s in a top down then bottom up, i.e. down up, order. See
                          listtd and listbu for a detailed description of each phase.
                          
                          which is longer than given to it.
                          
                          
                          ]]></description>
    <start>368</start>
    <end>369</end>
    <type><![CDATA[   List(a) -> List(b)]]></type>
    <param><![CDATA[s List(a) -> List(b)]]></param>
  </strategy>
  
  
  <strategy>
    <name>listdu2</name>
    <description><![CDATA[
                          Applies s1 in a top down order then s2 in a bottom up order. See
                          listd and listbu for a detailed description of each phase.
                          
                          which is longer than given to it.
                          
                          
                          ]]></description>
    <start>382</start>
    <end>383</end>
    <type><![CDATA[    List(a) -> List(b)]]></type>
    <param><![CDATA[s1 List(a) -> List(b)]]></param>
    <param><![CDATA[s2 List(a) -> List(b)]]></param>
  </strategy>
  
  
  <strategy>
    <name>RevInit</name>
    <description><![CDATA[
                          ]]></description>
    <start>386</start>
    <end>386</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>Rev</name>
    <description><![CDATA[
                          ]]></description>
    <start>389</start>
    <end>389</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>RevExit</name>
    <description><![CDATA[
                          ]]></description>
    <start>392</start>
    <end>392</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>reverse</name>
    <description><![CDATA[
                          Reverses a list.
                          
                          
                          ]]></description>
    <start>400</start>
    <end>401</end>
    <type><![CDATA[List(a) -> List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>reverse</name>
    <description><![CDATA[
                          Reverses a list and applies s to all the elements.
                          
                          
                          ]]></description>
    <start>409</start>
    <end>410</end>
    <type><![CDATA[ List(a) -> List(b)]]></type>
    <param><![CDATA[a -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>reverse-acc</name>
    <description><![CDATA[
                          ]]></description>
    <start>413</start>
    <end>414</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>reverse-acc</name>
    <description><![CDATA[
                          ]]></description>
    <start>417</start>
    <end>418</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>UptoInit</name>
    <description><![CDATA[
                          ]]></description>
    <start>423</start>
    <end>423</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>UptoExit</name>
    <description><![CDATA[
                          ]]></description>
    <start>426</start>
    <end>426</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>UptoStep</name>
    <description><![CDATA[
                          ]]></description>
    <start>429</start>
    <end>429</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>upto</name>
    <description><![CDATA[
                          Generates a sequence of numbers from 0 up to the given input
                          integer, inclusive.
                          
                          See also range.
                          
                          
                          
                          ]]></description>
    <start>443</start>
    <end>444</end>
    <type><![CDATA[Int -> List(Int)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>conc</name>
    <description><![CDATA[
                          Concatenates all lists of a tuple.
                          
                          
                          ]]></description>
    <start>454</start>
    <end>456</end>
    <type><![CDATA[(List(a), List(a), ...) -> List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>concat</name>
    <description><![CDATA[
                          Concatenates a list of lists into one list.
                          
                          Example: <concat> [[1,2],[3,4],[5,6]] => [1,2,3,4,5,6]
                          
                          
                          ]]></description>
    <start>466</start>
    <end>467</end>
    <type><![CDATA[List(List(a)) -> List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>makeConc</name>
    <description><![CDATA[
                          Concats two elements if both elements are lists. Otherwise, constructs
                          a Conc term.
                          
                          Generic term construction is used to avoid infinite recursion: makeConc
                          is used in the compilation of Conc itself.
                          
                          
                          ]]></description>
    <start>479</start>
    <end>481</end>
    <type><![CDATA[List(a) * List(b) -> List(a|b)]]></type>
    <type><![CDATA[a * b -> Conc(a,b)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>separate-by</name>
    <description><![CDATA[
                          Separates the elements of the list by the specified separator.
                          The separate-by variant that uses a term argument is prefered.
                          
                          
                          ]]></description>
    <start>491</start>
    <end>493</end>
    <type><![CDATA[(sep, List(a)) -> List(a or sep)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>separate-by</name>
    <description><![CDATA[
                          Separates the elements of the list by the specified separator.
                          The separate-by variant that uses a term argument is prefered.
                          
                          
                          ]]></description>
    <start>502</start>
    <end>503</end>
    <type><![CDATA[ List(a) -> List(a or sep)]]></type>
    <param><![CDATA[Strategy that results in a separator.]]></param>
  </strategy>
  
  
  <strategy>
    <name>separate-by</name>
    <description><![CDATA[
                          Separates the elements of the list by the specified separator.
                          
                          
                          ]]></description>
    <start>511</start>
    <end>518</end>
    <type><![CDATA[ List(a) -> List(a or sep)]]></type>
    <param><![CDATA[Separator term]]></param>
  </strategy>
  
  
  <strategy>
    <name>matrix-transpose</name>
    <description><![CDATA[
                          Transposes an n by m matrix. The matrix must be represented as
                          a list of n elements, where each element is a list of length m.
                          The element of the inner lists may be of any type.
                          
                          Example: <matrix-transpose> [[1,2],[3,4]] => [[1,3],[2,4]]
                          
                          
                          ]]></description>
    <start>531</start>
    <end>536</end>
    <type><![CDATA[List(List(a)) -> List(List(a))]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>for-each-pair</name>
    <description><![CDATA[
                          <for-each-pair(s)> (xs, ys) produces the list of pairs <s> (x,y).
                          for each pair of x from xs and y from ys.
                          
                          
                          
                          ]]></description>
    <start>546</start>
    <end>547</end>
    <type><![CDATA[List(a) * List(b) -> List((a,b), ...)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>member</name>
    <description><![CDATA[
                          Succeeds if the first input term is a member of the second.
                          
                          
                          ]]></description>
    <start>556</start>
    <end>556</end>
    <type><![CDATA[a * List(a) -> a]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>FoldR1</name>
    <description><![CDATA[
                          ]]></description>
    <start>561</start>
    <end>561</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>FoldR</name>
    <description><![CDATA[
                          ]]></description>
    <start>564</start>
    <end>564</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>FoldL</name>
    <description><![CDATA[
                          ]]></description>
    <start>567</start>
    <end>567</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>lsplit</name>
    <description><![CDATA[
                          ]]></description>
    <start>570</start>
    <end>570</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>foldr1</name>
    <description><![CDATA[
                          foldr, requires a list of length > 1.
                          
                          
                          ]]></description>
    <start>582</start>
    <end>583</end>
    <type><![CDATA[  List(a) -> b]]></type>
    <param><![CDATA[ List(a) -> b]]></param>
    <param><![CDATA[ (a, b) -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>foldr1</name>
    <description><![CDATA[
                          foldr, requires a list of length > 1.
                          The additional parameter strategy f is applied to each element just
                          before each folding step.
                          
                          
                          ]]></description>
    <start>596</start>
    <end>597</end>
    <type><![CDATA[ List(a) -> b]]></type>
    <param><![CDATA[List(c) -> b]]></param>
    <param><![CDATA[(c, b) -> b]]></param>
    <param><![CDATA[a -> c]]></param>
  </strategy>
  
  
  <strategy>
    <name>foldr1</name>
    <description><![CDATA[
                          foldr, requires a list of length > 1.
                          Note that s maps (a, a) to a, only one type is involved.
                          
                          
                          ]]></description>
    <start>607</start>
    <end>608</end>
    <type><![CDATA[ List(a) -> a]]></type>
    <param><![CDATA[(a, a) -> a]]></param>
  </strategy>
  
  
  <strategy>
    <name>foldr</name>
    <description><![CDATA[
                          Right folds a list. That is, the strategy s2 is applied as a
                          binary operator between all adjacent elements in the list.
                          foldr starts by applying s2 to the last element in the list
                          and the result of s1. s1 is therefore the starting point of
                          the folding.
                          
                          Example: <foldr(!0, add)> [1,2,3,4] => 10
                          
                          
                          ]]></description>
    <start>623</start>
    <end>625</end>
    <type><![CDATA[ List(a) -> b]]></type>
    <param><![CDATA[[] -> b]]></param>
    <param><![CDATA[(a, b) -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>foldr</name>
    <description><![CDATA[
                          Right folds a list. That is, the strategy s2 is applied as a
                          binary operator between all adjacent elements in the list.
                          foldr starts by applying s2 to the last element in the list
                          and the result of s1. s1 is therefore the starting point of
                          the folding.
                          
                          The additional parameter strategy f is applied to each element just
                          before each folding step.
                          
                          Example: <foldr(!0, add, inc)> [1,2,3,4] => 14
                          
                          
                          ]]></description>
    <start>644</start>
    <end>646</end>
    <type><![CDATA[ List(a) -> b]]></type>
    <param><![CDATA[[] -> b]]></param>
    <param><![CDATA[(c, b) -> b]]></param>
    <param><![CDATA[a -> c]]></param>
  </strategy>
  
  
  <strategy>
    <name>foldl</name>
    <description><![CDATA[
                          Left folds a list. That is, the strategy sis applied as a
                          binary operator between all adjacent elements in the list.
                          foldr starts by applying s to b and the first element in
                          the list. b is therefore the starting point of the folding.
                          
                          Example: <foldl(add)> ([1,2,3,4], 0)
                          
                          
                          ]]></description>
    <start>659</start>
    <end>660</end>
    <type><![CDATA[ (List(a), b) -> b]]></type>
    <param><![CDATA[(a, b) -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>mapfoldr1</name>
    <description><![CDATA[
                          ]]></description>
    <start>663</start>
    <end>664</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>mapconcat</name>
    <description><![CDATA[
                          Transform the elements of a list into lists (map)
                          and concatenate into a single list (concat).
                          
                          Note: equivalent to map(s); concat
                          
                          
                          ]]></description>
    <start>675</start>
    <end>676</end>
    <type><![CDATA[ List(a) -> List(b)]]></type>
    <param><![CDATA[a -> List(b)]]></param>
  </strategy>
  
  
  <strategy>
    <name>last</name>
    <description><![CDATA[
                          Returns the last element of a list.
                          
                          Fails if applied to the empty list.
                          
                          
                          ]]></description>
    <start>685</start>
    <end>686</end>
    <type><![CDATA[List(a) -> a]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>first-last</name>
    <description><![CDATA[
                          Returns a list with the first and the last element of
                          the input list. For the empty list and the singleton
                          list, this is equivalent to id.
                          
                          
                          ]]></description>
    <start>696</start>
    <end>697</end>
    <type><![CDATA[List(a) -> List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>init</name>
    <description><![CDATA[
                          Returns a list of all elements of a list, except the last.
                          
                          Fails if applied to the empty list.
                          
                          
                          
                          ]]></description>
    <start>709</start>
    <end>710</end>
    <type><![CDATA[List(a) -> List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>split-last</name>
    <description><![CDATA[
                          
                          ]]></description>
    <start>716</start>
    <end>717</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>copy</name>
    <description><![CDATA[
                          Makes n copies of a term into a list of duplicates. The
                          first input term is the integer n, the second is the term
                          to duplicate.
                          
                          
                          Example: <copy> (3, "foo") => ["foo", "foo", "foo"]
                          
                          
                          ]]></description>
    <start>730</start>
    <end>733</end>
    <type><![CDATA[Int * a -> List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>copy</name>
    <description><![CDATA[
                          Makes n copies of a term into a list of duplicates, applying
                          the strategy s to every copy. The first input term is the
                          integer n, the second is the term to duplicate.
                          
                          Example: <copy(\ "foo" -> "bar" \)> (3, "foo") => ["bar","bar,"bar"]
                          
                          
                          ]]></description>
    <start>745</start>
    <end>748</end>
    <type><![CDATA[   Int * a -> List(n)]]></type>
    <param><![CDATA[s       a -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>thread-map</name>
    <description><![CDATA[
                          ]]></description>
    <start>751</start>
    <end>752</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>thread-map</name>
    <description><![CDATA[
                          Applies s to each element in the list, keeping along a separate
                          context term.
                          
                          For each element in the list, a tuple (a, b) is constructed and
                          given to s. From the result, (a', b'), a' goes to the final list
                          returned by this strategy, and b' becomes the new b as s is
                          applied to the next element.
                          
                          Example: <thread-map(add ; !(<id>, <id>))> ([1,2,3,4], 1) => ([2,4,7,11],11)
                          
                          
                          ]]></description>
    <start>768</start>
    <end>771</end>
    <type><![CDATA[List(a) * b -> List(a') * b']]></type>
    <param><![CDATA[s a * b -> a' * b']]></param>
  </strategy>
  
  
  <strategy>
    <name>number</name>
    <description><![CDATA[
                          Numbers each element in a list successively with an
                          integer, starting at 0. The result is a list of pairs,
                          (elem, num) where elem is the original element and num
                          is its associated number. s is applied to each pair
                          before inserting it into the list
                          
                          Example: <number(id)> ["a","b","c"] => [("a",0),("b",1),("c",2)]
                          
                          
                          
                          ]]></description>
    <start>787</start>
    <end>788</end>
    <type><![CDATA[List(a) -> List((a,n),...)]]></type>
    <param><![CDATA[s a * Int -> a' * Int]]></param>
  </strategy>
  
  
  <strategy>
    <name>take-while</name>
    <description><![CDATA[
                          Take elements from the start of a list while s succeeds.
                          Each element of the list is tested against s, starting at
                          the head of the list. For as long as s succeeds, the elements
                          are accumulated in a list, which is returned as s fails, or
                          the end of the list is reached. The actual term returned by
                          s is ignored.
                          
                          Example: <take-while(?2 ; !3)> [2,2,3] => [2,2]
                          
                          
                          ]]></description>
    <start>803</start>
    <end>804</end>
    <type><![CDATA[   List(a) -> List(a)]]></type>
    <param><![CDATA[s       a -> _]]></param>
  </strategy>
  
  
  <strategy>
    <name>take-until</name>
    <description><![CDATA[
                          Take elements from the start of a list until s succeeds.
                          Each element of the list is tested against s, starting at
                          the head of the list. For as long as s does not succeed, the
                          elements are accumulated in a list, which is returned at
                          the instant s fails. The actual term returned by s is
                          ignored. If s never succeeds, the entire list is returned.
                          
                          Example: <take-until(?2; !3)> [3,3,2,4] => [3,3]
                          
                          
                          ]]></description>
    <start>819</start>
    <end>820</end>
    <type><![CDATA[   List(a) -> List(a)]]></type>
    <param><![CDATA[s       a -> _]]></param>
  </strategy>
  
  
  <strategy>
    <name>take</name>
    <description><![CDATA[
                          Take the first n elements of a list, given by isn. The
                          strategy argument isn must produce an integer, which
                          gives the length of the sublist to return. If there are
                          not enough elements, this strategy fails.
                          
                          
                          ]]></description>
    <start>831</start>
    <end>832</end>
    <type><![CDATA[List(a) -> List(a)]]></type>
    <param><![CDATA[isn _ -> Int]]></param>
  </strategy>
  
  
  <strategy>
    <name>take</name>
    <description><![CDATA[
                          Returns the first n elements of a list, fails
                          if list has fewer than n elements.
                          
                          
                          ]]></description>
    <start>841</start>
    <end>846</end>
    <type><![CDATA[List(a) -> List(a)]]></type>
    <param><![CDATA[n The number of elements to take.]]></param>
  </strategy>
  
  
  <strategy>
    <name>takemap</name>
    <description><![CDATA[
                          Returns the n first elements after s has been applied to them.
                          With the exception of side effects, takemap(s|n) is equal to
                          take(|n); map(s). The difference when considering side-effects
                          is that s is applied while taking elements, so if s has a
                          side-effect these will be performed, even if take fails.
                          
                          
                          ]]></description>
    <start>859</start>
    <end>864</end>
    <type><![CDATA[List(a) -> List(b)]]></type>
    <param><![CDATA[n - The number of elements to retrieve]]></param>
    <param><![CDATA[s a -> b]]></param>
  </strategy>
  
  
  <strategy>
    <name>drop-while</name>
    <description><![CDATA[
                          Drops elements from the start of a list while s succeeds. The
                          first element at which s fails and all following it will be
                          returned.
                          
                          Example: <drop-while(?2)> [2,2,3,4] => [3,4]
                          
                          
                          ]]></description>
    <start>876</start>
    <end>877</end>
    <type><![CDATA[   List(a) -> List(a)]]></type>
    <param><![CDATA[s       a -> _]]></param>
  </strategy>
  
  
  <strategy>
    <name>drop-until</name>
    <description><![CDATA[
                          Drops elements from the start of a list until s succeeds. The
                          first element at which s succeeds and all following it will be
                          returned.
                          
                          Example: <drop-until(?3)> [2,2,3,4] => [3,4]
                          
                          
                          ]]></description>
    <start>889</start>
    <end>890</end>
    <type><![CDATA[   List(a) -> List(a)]]></type>
    <param><![CDATA[s       a -> _]]></param>
  </strategy>
  
  
  <strategy>
    <name>drop</name>
    <description><![CDATA[
                          Drops the first n elements from a list. If the list has
                          fewer than n elements, the strategy fails.
                          
                          
                          ]]></description>
    <start>899</start>
    <end>904</end>
    <type><![CDATA[ List(a) -> List(a)]]></type>
    <param><![CDATA[n - the number of elements to drop]]></param>
  </strategy>
  
  
  <strategy>
    <name>splitmap</name>
    <description><![CDATA[
                          Splits a list after n elements and applies strategy s to the
                          first sublist. The second sublist is left untouched.
                          Disregarding side-effects, splitmap is equal to
                          !(<take(|n); map(s)>, <drop(|n)>). If side-effects are
                          considered, note that application of s happens while
                          traversing and splitting.
                          
                          
                          ]]></description>
    <start>918</start>
    <end>925</end>
    <type><![CDATA[List(a) -> (List(b), List(a))]]></type>
    <param><![CDATA[s a -> b]]></param>
    <param><![CDATA[n - the number of elements to apply s to, from the start]]></param>
  </strategy>
  
  
  <strategy>
    <name>split-at</name>
    <description><![CDATA[
                          
                          ]]></description>
    <start>931</start>
    <end>932</end>
    
    
  </strategy>
  
  
  <strategy>
    <name>back-split-at</name>
    <description><![CDATA[
                          Splits a list in two, with the second part containing the last
                          n elements and and first part containing all elements except the
                          last n.
                          
                          
                          ]]></description>
    <start>942</start>
    <end>952</end>
    <type><![CDATA[List(a) -> (List(a), List(a))]]></type>
    <param><![CDATA[n - the number of elements to split at (counting from the back)]]></param>
  </strategy>
  
  
  <strategy>
    <name>drop</name>
    <description><![CDATA[
                          Drops a number of terms from the front of a list.
                          
                          The number is specified by the strategy argument, which should
                          produce an integer.
                          
                          
                          ]]></description>
    <start>963</start>
    <end>967</end>
    <type><![CDATA[ List(a) -> List(a)]]></type>
    <param><![CDATA[_ -> Int]]></param>
  </strategy>
  
  
  <strategy>
    <name>split-at</name>
    <description><![CDATA[
                          Splits the list in two sublists, containing elements from 0 to
                          n and from n onwards.
                          
                          Example: <split-at(|4)>[1,2,3,4,5,6,7,8,9] => ([1,2,3,4], [5,6,7,8,9])
                          
                          
                          ]]></description>
    <start>977</start>
    <end>979</end>
    <type><![CDATA[List(a) -> (List(a), List(a))]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>rtrim</name>
    <description><![CDATA[
                          Trim elements from the end of a list
                          
                          Removes the longest sublist from the end of a list, for which
                          all elements satisfy the strategy s.
                          
                          
                          ]]></description>
    <start>994</start>
    <end>1000</end>
    <type><![CDATA[ List(a) -> List(a)]]></type>
    <param><![CDATA[should succeed for all elements that have to be trimmed.]]></param>
  </strategy>
  
  
  <strategy>
    <name>ltrim</name>
    <description><![CDATA[
                          Trim elements from the start of a list.
                          
                          Removes the longest sublist from the start of a list, for which
                          all elements satisfy the strategy s.
                          
                          
                          ]]></description>
    <start>1014</start>
    <end>1014</end>
    <type><![CDATA[ List(a) -> List(a)]]></type>
    <param><![CDATA[should succeed for all elements that have to be trimmed.]]></param>
  </strategy>
  
  
  <strategy>
    <name>trim</name>
    <description><![CDATA[
                          Trim elements from both start and end of a list.
                          
                          Removest the longest sublist from both start and end of a
                          list for which all elements satisfy s.
                          
                          
                          ]]></description>
    <start>1027</start>
    <end>1027</end>
    <type><![CDATA[List(a) -> List(a)]]></type>
    <param><![CDATA[s a -> -]]></param>
  </strategy>
  
  
  <strategy>
    <name>flatten-list</name>
    <description><![CDATA[
                          Completely flattens a list and its sublists to a single list.
                          
                          See list-misc-test for examples.
                          
                          
                          ]]></description>
    <start>1039</start>
    <end>1040</end>
    <type><![CDATA[List(rec x(a or List(x))) -> List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>eliminate-common-suffix</name>
    <description><![CDATA[
                          Eliminates all elements at the end of the two lists that are equal.
                          Only works correctly on lists of equal length!
                          
                          Example: <eliminate-common-suffix>([1,3,4], [1,2,4]) => ([1,3], [1,2])
                          
                          
                          ]]></description>
    <start>1051</start>
    <end>1058</end>
    <type><![CDATA[(List(a), List(a)) -> (List(a), List(a))]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>common-prefix</name>
    <description><![CDATA[
                          Returns the common prefix of two lists.
                          
                          Examples:
                          <common-prefix>([1,2,3], [1,2,4,5]) => [1,2]
                          <common-prefix>([1,2,3], [2,3,4]) => []
                          
                          
                          ]]></description>
    <start>1069</start>
    <end>1072</end>
    <type><![CDATA[(List(a), List(a)) -> List(a)]]></type>
    
  </strategy>
  
  
  <strategy>
    <name>list-combinations</name>
    <description><![CDATA[
                          Returns a list of combinations by choosing one element from every
                          list, in every possible combination.
                          
                          Examples:
                          
                          $ <list-combinations> [[1, 2]]
                          [[1],[2]]
                          
                          $ <list-combinations> [[1, 2], []]
                          []
                          
                          $ <list-combinations> [[1, 2], ["a", "b"]]
                          [[1,"a"],[2,"a"],[1,"b"],[2,"b"]]
                          
                          $ <list-combinations> []
                          [[]]
                          
                          
                          ]]></description>
    <start>1099</start>
    <end>1134</end>
    <type><![CDATA[List(List(a)) -> List(List(a))]]></type>
    
  </strategy>
  
</module>
